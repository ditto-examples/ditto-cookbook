{
  "codeBlocks": [
    {
      "index": 0,
      "language": "dart",
      "originalCode": "// ✅ GOOD: Proper error handling for Ditto initialization\ntry {\n  final ditto = await Ditto.open(\n    identity: OnlinePlaygroundIdentity(appId: appId, token: token),\n  );\n  await ditto.startSync();\n} on DittoError catch (e) {\n  // Handle Ditto-specific errors (licensing, permissions, etc.)\n  print('Ditto initialization failed: ${e.message}');\n  showErrorDialog('Failed to initialize sync');\n} catch (e) {\n  // Handle unexpected errors\n  print('Unexpected error: $e');\n}",
      "translatedCode": "// ✅ 良い例: Ditto初期化の適切なエラーハンドリング\ntry {\n  final ditto = await Ditto.open(\n    identity: OnlinePlaygroundIdentity(appId: appId, token: token),\n  );\n  await ditto.startSync();\n} on DittoError catch (e) {\n  // Ditto固有のエラーを処理（ライセンス、権限など）\n  print('Ditto initialization failed: ${e.message}');\n  showErrorDialog('Failed to initialize sync');\n} catch (e) {\n  // 予期しないエラーを処理\n  print('Unexpected error: $e');\n}",
      "hasComments": true
    },
    {
      "index": 1,
      "language": "dart",
      "originalCode": "// ❌ BAD: Missing await (settings might not apply before sync)\nditto.store.execute('ALTER SYSTEM SET DQL_STRICT_MODE = false'); // No await!\nawait ditto.startSync(); // May start with wrong settings\n\n// ✅ GOOD: Always await ALTER SYSTEM SET\nawait ditto.store.execute('ALTER SYSTEM SET DQL_STRICT_MODE = false');\nawait ditto.startSync(); // Settings guaranteed to be applied",
      "translatedCode": "// ❌ 悪い例: awaitの欠落（同期前に設定が適用されない可能性がある）\nditto.store.execute('ALTER SYSTEM SET DQL_STRICT_MODE = false'); // awaitがない！\nawait ditto.startSync(); // 誤った設定で開始される可能性がある\n\n// ✅ 良い例: ALTER SYSTEM SETは常にawaitする\nawait ditto.store.execute('ALTER SYSTEM SET DQL_STRICT_MODE = false');\nawait ditto.startSync(); // 設定が確実に適用される",
      "hasComments": true
    },
    {
      "index": 2,
      "language": "dart",
      "originalCode": "// ❌ BAD: Sequential IDs cause collisions across offline devices\nint orderCounter = 1;\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order)',\n  arguments: {\n    'order': {'_id': 'order_${orderCounter++}', 'item': 'Coffee'}\n  },\n);\n// Device A creates \"order_1\", Device B also creates \"order_1\" → Collision!\n\n// ✅ GOOD: Let Ditto auto-generate globally unique IDs\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order)',\n  arguments: {\n    'order': {'item': 'Coffee'}  // No _id → Ditto auto-generates\n  },\n);",
      "translatedCode": "// ❌ 悪い例: 連番IDはオフラインデバイス間で衝突を引き起こす\nint orderCounter = 1;\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order)',\n  arguments: {\n    'order': {'_id': 'order_${orderCounter++}', 'item': 'Coffee'}\n  },\n);\n// デバイスAが「order_1」を作成、デバイスBも「order_1」を作成 → 衝突！\n\n// ✅ 良い例: Dittoにグローバルに一意なIDを自動生成させる\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order)',\n  arguments: {\n    'order': {'item': 'Coffee'}  // _idなし → Dittoが自動生成\n  },\n);",
      "hasComments": true
    },
    {
      "index": 3,
      "language": "dart",
      "originalCode": "// ❌ BAD: Array with concurrent updates (Last-Write-Wins)\n{\n  \"_id\": \"order_123\",\n  \"items\": [{\"id\": \"item1\", \"qty\": 2}]  // Merge conflicts!\n}\n\n// ✅ GOOD: MAP structure for concurrent updates\n{\n  \"_id\": \"order_123\",\n  \"items\": {\"item1\": {\"qty\": 2, \"productId\": \"p1\"}}  // Merge-safe\n}",
      "translatedCode": "// ❌ 悪い例: 並行更新される配列（Last-Write-Wins）\n{\n  \"_id\": \"order_123\",\n  \"items\": [{\"id\": \"item1\", \"qty\": 2}]  // マージ時に競合！\n}\n\n// ✅ 良い例: 並行更新のためのMAP構造\n{\n  \"_id\": \"order_123\",\n  \"items\": {\"item1\": {\"qty\": 2, \"productId\": \"p1\"}}  // マージ安全\n}",
      "hasComments": true
    },
    {
      "index": 4,
      "language": "dart",
      "originalCode": "// ❌ BAD: Storing calculated values (wastes bandwidth, risk of stale data)\n{\n  \"_id\": \"order_123\",\n  \"items\": {\n    \"item_1\": {\"price\": 12.99, \"quantity\": 2, \"lineTotal\": 25.98}  // ❌ Calculated!\n  },\n  \"subtotal\": 25.98,  // ❌ Calculated!\n  \"tax\": 2.60,        // ❌ Calculated!\n  \"total\": 28.58      // ❌ Calculated!\n}\n\n// ✅ GOOD: Store only source data, calculate in app\n{\n  \"_id\": \"order_123\",\n  \"items\": {\n    \"item_1\": {\"price\": 12.99, \"quantity\": 2}  // Source data only\n  }\n}\n\n// Calculate on-demand in application\ndouble calculateLineTotal(Map<String, dynamic> item) {\n  return item['price'] * item['quantity'];\n}\n\ndouble calculateTotal(Map<String, dynamic> items, double taxRate) {\n  final subtotal = items.values.fold(0.0,\n    (sum, item) => sum + (item['price'] * item['quantity']));\n  return subtotal + (subtotal * taxRate);\n}",
      "translatedCode": "// ❌ 悪い例: 計算値を保存（帯域幅の無駄、古いデータのリスク）\n{\n  \"_id\": \"order_123\",\n  \"items\": {\n    \"item_1\": {\"price\": 12.99, \"quantity\": 2, \"lineTotal\": 25.98}  // ❌ 計算値！\n  },\n  \"subtotal\": 25.98,  // ❌ 計算値！\n  \"tax\": 2.60,        // ❌ 計算値！\n  \"total\": 28.58      // ❌ 計算値！\n}\n\n// ✅ 良い例: ソースデータのみを保存、アプリで計算\n{\n  \"_id\": \"order_123\",\n  \"items\": {\n    \"item_1\": {\"price\": 12.99, \"quantity\": 2}  // ソースデータのみ\n  }\n}\n\n// アプリケーション内でオンデマンドで計算\ndouble calculateLineTotal(Map<String, dynamic> item) {\n  return item['price'] * item['quantity'];\n}\n\ndouble calculateTotal(Map<String, dynamic> items, double taxRate) {\n  final subtotal = items.values.fold(0.0,\n    (sum, item) => sum + (item['price'] * item['quantity']));\n  return subtotal + (subtotal * taxRate);\n}",
      "hasComments": true
    },
    {
      "index": 5,
      "language": "dart",
      "originalCode": "// ❌ BAD: Syncing unnecessary data\n{\n  \"_id\": \"task_123\",\n  \"title\": \"Review PR\",\n  \"status\": \"pending\",\n  // ❌ UI state (device-specific, not business data)\n  \"isExpanded\": true,\n  \"selectedTab\": 2,\n  // ❌ Temporary state (transient, changes frequently)\n  \"uploadProgress\": 67,\n  \"isProcessing\": false,\n  // ❌ Device-specific (only relevant to one device)\n  \"localFilePath\": \"/storage/cache/task_123.tmp\",\n  // ❌ Cached data (can be fetched from external source)\n  \"userAvatarUrl\": \"https://api.example.com/avatars/user_789.jpg\"\n}\n\n// ✅ GOOD: Only business state synced, other data managed locally\n{\n  \"_id\": \"task_123\",\n  \"title\": \"Review PR\",\n  \"status\": \"pending\",\n  \"assignee\": \"user_789\"  // Business data: who's responsible\n}\n\n// Store non-business state locally (ViewModel, cache, device storage):\nclass TaskViewModel {\n  final Task task;  // Ditto business data\n  bool isExpanded = false;  // UI state (local)\n  double uploadProgress = 0.0;  // Temporary state (local)\n  String? cachedAvatarUrl;  // Cached data (fetched as needed)\n}",
      "translatedCode": "// ❌ 悪い例: 不要なデータを同期\n{\n  \"_id\": \"task_123\",\n  \"title\": \"Review PR\",\n  \"status\": \"pending\",\n  // ❌ UIの状態（デバイス固有、ビジネスデータではない）\n  \"isExpanded\": true,\n  \"selectedTab\": 2,\n  // ❌ 一時的な状態（一過性、頻繁に変化）\n  \"uploadProgress\": 67,\n  \"isProcessing\": false,\n  // ❌ デバイス固有（1つのデバイスのみに関連）\n  \"localFilePath\": \"/storage/cache/task_123.tmp\",\n  // ❌ キャッシュされたデータ（外部ソースから取得可能）\n  \"userAvatarUrl\": \"https://api.example.com/avatars/user_789.jpg\"\n}\n\n// ✅ 良い例: ビジネス状態のみを同期、その他のデータはローカルで管理\n{\n  \"_id\": \"task_123\",\n  \"title\": \"Review PR\",\n  \"status\": \"pending\",\n  \"assignee\": \"user_789\"  // ビジネスデータ: 担当者\n}\n\n// 非ビジネス状態はローカルに保存（ViewModel、キャッシュ、デバイスストレージ）:\nclass TaskViewModel {\n  final Task task;  // Dittoのビジネスデータ\n  bool isExpanded = false;  // UIの状態（ローカル）\n  double uploadProgress = 0.0;  // 一時的な状態（ローカル）\n  String? cachedAvatarUrl;  // キャッシュされたデータ（必要に応じて取得）\n}",
      "hasComments": true
    },
    {
      "index": 6,
      "language": "dart",
      "originalCode": "// ❌ BAD: Full document replacement (unnecessary sync traffic)\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order) ON ID CONFLICT DO UPDATE',\n  arguments: {\n    'order': {'_id': 'o1', 'status': 'done', 'customer': 'c1', 'items': [...]}\n  },\n);\n\n// ✅ GOOD: Field-level update (only changed field syncs)\nawait ditto.store.execute(\n  'UPDATE orders SET status = :status WHERE _id = :id',\n  arguments: {'id': 'o1', 'status': 'done'},\n);",
      "translatedCode": "// ❌ 悪い例: ドキュメント全体の置き換え（不要な同期トラフィック）\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order) ON ID CONFLICT DO UPDATE',\n  arguments: {\n    'order': {'_id': 'o1', 'status': 'done', 'customer': 'c1', 'items': [...]}\n  },\n);\n\n// ✅ 良い例: フィールドレベルの更新（変更されたフィールドのみ同期）\nawait ditto.store.execute(\n  'UPDATE orders SET status = :status WHERE _id = :id',\n  arguments: {'id': 'o1', 'status': 'done'},\n);",
      "hasComments": true
    },
    {
      "index": 7,
      "language": "dart",
      "originalCode": "// ❌ BAD: DO UPDATE syncs ALL fields (even unchanged)\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order) ON ID CONFLICT DO UPDATE',\n  arguments: {\n    'order': {'_id': 'o1', 'status': 'done', 'customer': 'c1'}\n  },\n);\n\n// ✅ GOOD: DO UPDATE_LOCAL_DIFF only syncs changed fields (SDK 4.12+)\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order) ON ID CONFLICT DO UPDATE_LOCAL_DIFF',\n  arguments: {\n    'order': {'_id': 'o1', 'status': 'done', 'customer': 'c1'}\n  },\n);",
      "translatedCode": "// ❌ 悪い例: DO UPDATEはすべてのフィールドを同期（未変更でも）\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order) ON ID CONFLICT DO UPDATE',\n  arguments: {\n    'order': {'_id': 'o1', 'status': 'done', 'customer': 'c1'}\n  },\n);\n\n// ✅ 良い例: DO UPDATE_LOCAL_DIFFは変更されたフィールドのみ同期（SDK 4.12+）\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order) ON ID CONFLICT DO UPDATE_LOCAL_DIFF',\n  arguments: {\n    'order': {'_id': 'o1', 'status': 'done', 'customer': 'c1'}\n  },\n);",
      "hasComments": true
    },
    {
      "index": 8,
      "language": "dart",
      "originalCode": "// ❌ BAD: SET operation for counters (lost updates)\nfinal product = (await ditto.store.execute(\n  'SELECT * FROM products WHERE _id = :id', arguments: {'id': 'p1'}\n)).items.first.value;\nawait ditto.store.execute(\n  'UPDATE products SET viewCount = :count WHERE _id = :id',\n  arguments: {'count': (product['viewCount'] ?? 0) + 1, 'id': 'p1'},\n);\n\n// ✅ GOOD: COUNTER type for distributed counters (SDK 4.14.0+)\nawait ditto.store.execute(\n  'UPDATE products APPLY viewCount COUNTER INCREMENT BY 1.0 WHERE _id = :id',\n  arguments: {'id': 'p1'},\n);",
      "translatedCode": "// ❌ 悪い例: カウンターのSET操作（更新の喪失）\nfinal product = (await ditto.store.execute(\n  'SELECT * FROM products WHERE _id = :id', arguments: {'id': 'p1'}\n)).items.first.value;\nawait ditto.store.execute(\n  'UPDATE products SET viewCount = :count WHERE _id = :id',\n  arguments: {'count': (product['viewCount'] ?? 0) + 1, 'id': 'p1'},\n);\n\n// ✅ 良い例: 分散カウンター用のCOUNTERタイプ（SDK 4.14.0+）\nawait ditto.store.execute(\n  'UPDATE products APPLY viewCount COUNTER INCREMENT BY 1.0 WHERE _id = :id',\n  arguments: {'id': 'p1'},\n);",
      "hasComments": true
    },
    {
      "index": 9,
      "language": "dart",
      "originalCode": "// ❌ BAD: Using counter for derived inventory value\n// Product document maintains currentStock counter\n{\n  \"_id\": \"product_123\",\n  \"name\": \"Coffee Beans\",\n  \"currentStock\": 50  // ❌ Counter updated from orders collection\n}\n\n// When order is placed, must update TWO collections:\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order)',\n  arguments: {'order': {'_id': 'o1', 'productId': 'product_123', 'qty': 5}}\n);\nawait ditto.store.execute(\n  'UPDATE products APPLY currentStock PN_INCREMENT BY -5.0 WHERE _id = :id',\n  arguments: {'id': 'product_123'}\n);\n// Problems: Cross-collection coupling, integrity risk, not self-correcting\n\n// ✅ GOOD: Calculate inventory from order history\n// Product document has no stock counter\n{\n  \"_id\": \"product_123\",\n  \"name\": \"Coffee Beans\",\n  \"initialStock\": 100  // Starting inventory (baseline)\n}\n\n// Order documents are source of truth\n{'_id': 'o1', 'productId': 'product_123', 'qty': 5}\n{'_id': 'o2', 'productId': 'product_123', 'qty': 10}\n\n// Calculate current stock from orders when needed:\nint calculateCurrentStock(String productId) {\n  final product = getProduct(productId);\n  final orders = getOrders(productId);\n  final totalOrdered = orders.fold(0, (sum, order) => sum + order['qty']);\n  return product['initialStock'] - totalOrdered;\n}\n// Benefits: Single source of truth, self-correcting, no cross-collection updates",
      "translatedCode": "// ❌ 悪い例: 派生在庫値のためにカウンターを使用\n// 商品ドキュメントがcurrentStockカウンターを維持\n{\n  \"_id\": \"product_123\",\n  \"name\": \"Coffee Beans\",\n  \"currentStock\": 50  // ❌ ordersコレクションから更新されるカウンター\n}\n\n// 注文が配置されると、2つのコレクションを更新する必要がある:\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order)',\n  arguments: {'order': {'_id': 'o1', 'productId': 'product_123', 'qty': 5}}\n);\nawait ditto.store.execute(\n  'UPDATE products APPLY currentStock PN_INCREMENT BY -5.0 WHERE _id = :id',\n  arguments: {'id': 'product_123'}\n);\n// 問題点: コレクション間の結合、整合性リスク、自己修正されない\n\n// ✅ 良い例: 注文履歴から在庫を計算\n// 商品ドキュメントには在庫カウンターがない\n{\n  \"_id\": \"product_123\",\n  \"name\": \"Coffee Beans\",\n  \"initialStock\": 100  // 開始在庫（ベースライン）\n}\n\n// 注文ドキュメントが真実のソース\n{'_id': 'o1', 'productId': 'product_123', 'qty': 5}\n{'_id': 'o2', 'productId': 'product_123', 'qty': 10}\n\n// 必要なときに注文から現在の在庫を計算:\nint calculateCurrentStock(String productId) {\n  final product = getProduct(productId);\n  final orders = getOrders(productId);\n  final totalOrdered = orders.fold(0, (sum, order) => sum + order['qty']);\n  return product['initialStock'] - totalOrdered;\n}\n// 利点: 単一の真実のソース、自己修正、コレクション間の更新なし",
      "hasComments": true
    },
    {
      "index": 10,
      "language": "dart",
      "originalCode": "// ❌ WRONG: Filtering deletion flags in subscriptions\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders WHERE isDeleted != true',  // Blocks relay!\n);\n\n// ✅ CORRECT: Subscribe broadly, filter in observer\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders',  // No filter - allows multi-hop relay\n);\nfinal observer = ditto.store.registerObserverWithSignalNext(\n  'SELECT * FROM orders WHERE isDeleted != true',  // Filter here\n  onChange: (result, signalNext) {\n    updateUI(result.items);\n    signalNext();\n  },\n);",
      "translatedCode": "// ❌ 誤り: サブスクリプションで削除フラグをフィルタリング\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders WHERE isDeleted != true',  // リレーをブロック！\n);\n\n// ✅ 正しい: 広くサブスクライブし、オブザーバーでフィルタリング\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders',  // フィルタなし - マルチホップリレーを許可\n);\nfinal observer = ditto.store.registerObserverWithSignalNext(\n  'SELECT * FROM orders WHERE isDeleted != true',  // ここでフィルタリング\n  onChange: (result, signalNext) {\n    updateUI(result.items);\n    signalNext();\n  },\n);",
      "hasComments": true
    },
    {
      "index": 11,
      "language": "dart",
      "originalCode": "// ❌ BAD: EVICT without canceling subscription (resync loop!)\nawait ditto.store.execute(\n  'EVICT FROM orders WHERE deletedAt < :cutoff',\n  arguments: {'cutoff': cutoffDate},\n);\n\n// ✅ GOOD: Cancel subscription → EVICT → Recreate with updated filter\norderSubscription?.cancel();  // Step 1: Cancel first\nawait ditto.store.execute(\n  'EVICT FROM orders WHERE isDeleted = true AND deletedAt < :cutoff',\n  arguments: {'cutoff': cutoffDate},\n);\norderSubscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders WHERE isDeleted != true',\n);",
      "translatedCode": "// ❌ 悪い例: サブスクリプションをキャンセルせずにEVICT（再同期ループ！）\nawait ditto.store.execute(\n  'EVICT FROM orders WHERE deletedAt < :cutoff',\n  arguments: {'cutoff': cutoffDate},\n);\n\n// ✅ 良い例: サブスクリプションをキャンセル → EVICT → 更新されたフィルタで再作成\norderSubscription?.cancel();  // ステップ1: 最初にキャンセル\nawait ditto.store.execute(\n  'EVICT FROM orders WHERE isDeleted = true AND deletedAt < :cutoff',\n  arguments: {'cutoff': cutoffDate},\n);\norderSubscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders WHERE isDeleted != true',\n);",
      "hasComments": true
    },
    {
      "index": 12,
      "language": "dart",
      "originalCode": "// ❌ PROBLEM: DELETE + concurrent UPDATE = husked document\n// Device A:\nawait ditto.store.execute('DELETE FROM cars WHERE _id = :id', arguments: {'id': 'car1'});\n// Device B (offline):\nawait ditto.store.execute('UPDATE cars SET color = :color WHERE _id = :id', arguments: {'color': 'blue', 'id': 'car1'});\n// Result after sync: {_id: \"car1\", color: \"blue\", make: null, model: null}\n\n// ✅ SOLUTION: Soft-Delete prevents husked documents\nawait ditto.store.execute(\n  'UPDATE cars SET isDeleted = true, deletedAt = :time WHERE _id = :id',\n  arguments: {'time': DateTime.now().toIso8601String(), 'id': 'car1'},\n);",
      "translatedCode": "// ❌ 問題: DELETE + 並行UPDATE = ハスク化ドキュメント\n// デバイスA:\nawait ditto.store.execute('DELETE FROM cars WHERE _id = :id', arguments: {'id': 'car1'});\n// デバイスB（オフライン）:\nawait ditto.store.execute('UPDATE cars SET color = :color WHERE _id = :id', arguments: {'color': 'blue', 'id': 'car1'});\n// 同期後の結果: {_id: \"car1\", color: \"blue\", make: null, model: null}\n\n// ✅ 解決策: Soft-Deleteはハスク化ドキュメントを防ぐ\nawait ditto.store.execute(\n  'UPDATE cars SET isDeleted = true, deletedAt = :time WHERE _id = :id',\n  arguments: {'time': DateTime.now().toIso8601String(), 'id': 'car1'},\n);",
      "hasComments": true
    },
    {
      "index": 13,
      "language": "dart",
      "originalCode": "// ❌ BAD: Fetch all documents, filter in application code\nfinal result = await ditto.store.execute('SELECT * FROM orders');\nfinal activeOrders = result.items\n  .map((item) => item.value)\n  .where((order) => order['status'] == 'active')\n  .toList();\n// Problems: High memory usage, slow deserialization, all documents loaded\n\n// ✅ GOOD: Filter at database level with WHERE clause\nfinal result = await ditto.store.execute(\n  'SELECT * FROM orders WHERE status = :status',\n  arguments: {'status': 'active'},\n);\nfinal activeOrders = result.items.map((item) => item.value).toList();\n// Benefits: Low memory usage, fast query, only filtered documents loaded",
      "translatedCode": "// ❌ 悪い例: すべてのドキュメントを取得し、アプリケーションコードでフィルタリング\nfinal result = await ditto.store.execute('SELECT * FROM orders');\nfinal activeOrders = result.items\n  .map((item) => item.value)\n  .where((order) => order['status'] == 'active')\n  .toList();\n// 問題点: メモリ使用量が多い、デシリアライゼーションが遅い、すべてのドキュメントがロードされる\n\n// ✅ 良い例: WHERE句でデータベースレベルでフィルタリング\nfinal result = await ditto.store.execute(\n  'SELECT * FROM orders WHERE status = :status',\n  arguments: {'status': 'active'},\n);\nfinal activeOrders = result.items.map((item) => item.value).toList();\n// 利点: メモリ使用量が少ない、クエリが高速、フィルタリングされたドキュメントのみがロードされる",
      "hasComments": true
    },
    {
      "index": 14,
      "language": "dart",
      "originalCode": "// ❌ BAD: Retaining QueryResultItem references (memory leak)\nclass OrdersViewModel {\n  List<QueryResultItem> _orderItems = [];  // ❌ Storing cursors!\n\n  void updateOrders(QueryResult result) {\n    _orderItems = result.items.toList();  // ❌ Long-lived references\n  }\n\n  void displayOrder(int index) {\n    final order = _orderItems[index].value;  // ❌ Using stale cursor\n    print('Order: ${order['title']}');\n  }\n}\n// Problem: Holds QueryResultItem cursors indefinitely, memory never released\n\n// ✅ GOOD: Extract data immediately, store plain objects\nclass OrdersViewModel {\n  List<Order> _orders = [];  // ✅ Plain application models\n\n  void updateOrders(QueryResult result) {\n    // Extract data immediately and convert to models\n    _orders = result.items\n      .map((item) => Order.fromMap(item.value))\n      .toList();\n    // QueryResultItems fall out of scope here, GC can clean them up\n  }\n\n  void displayOrder(int index) {\n    final order = _orders[index];  // ✅ Using plain model\n    print('Order: ${order.title}');\n  }\n}\n\n// Application model (plain Dart class)\nclass Order {\n  final String id;\n  final String title;\n  final String status;\n\n  Order({required this.id, required this.title, required this.status});\n\n  factory Order.fromMap(Map<String, dynamic> map) {\n    return Order(\n      id: map['_id'] as String,\n      title: map['title'] as String,\n      status: map['status'] as String,\n    );\n  }\n}",
      "translatedCode": "// ❌ 悪い例: QueryResultItem参照を保持（メモリリーク）\nclass OrdersViewModel {\n  List<QueryResultItem> _orderItems = [];  // ❌ カーソルを保存！\n\n  void updateOrders(QueryResult result) {\n    _orderItems = result.items.toList();  // ❌ 長期間の参照\n  }\n\n  void displayOrder(int index) {\n    final order = _orderItems[index].value;  // ❌ 古いカーソルを使用\n    print('Order: ${order['title']}');\n  }\n}\n// 問題点: QueryResultItemカーソルを無期限に保持、メモリが解放されない\n\n// ✅ 良い例: データをすぐに抽出し、プレーンオブジェクトを保存\nclass OrdersViewModel {\n  List<Order> _orders = [];  // ✅ プレーンなアプリケーションモデル\n\n  void updateOrders(QueryResult result) {\n    // データをすぐに抽出してモデルに変換\n    _orders = result.items\n      .map((item) => Order.fromMap(item.value))\n      .toList();\n    // ここでQueryResultItemsがスコープ外になり、GCがクリーンアップできる\n  }\n\n  void displayOrder(int index) {\n    final order = _orders[index];  // ✅ プレーンモデルを使用\n    print('Order: ${order.title}');\n  }\n}\n\n// アプリケーションモデル（プレーンなDartクラス）\nclass Order {\n  final String id;\n  final String title;\n  final String status;\n\n  Order({required this.id, required this.title, required this.status});\n\n  factory Order.fromMap(Map<String, dynamic> map) {\n    return Order(\n      id: map['_id'] as String,\n      title: map['title'] as String,\n      status: map['status'] as String,\n    );\n  }\n}",
      "hasComments": true
    },
    {
      "index": 15,
      "language": "dart",
      "originalCode": "// ❌ BAD: Request/response pattern (treating Ditto like HTTP)\nFuture<List<Order>> fetchOrders() async {\n  final sub = ditto.sync.registerSubscription('SELECT * FROM orders');\n  await Future.delayed(Duration(seconds: 2));  // Inefficient waiting!\n  final result = await ditto.store.execute('SELECT * FROM orders');\n  sub.cancel();  // Defeats mesh sync benefits\n  return result.items.map((item) => Order.fromMap(item.value)).toList();\n}\n\n// ✅ GOOD: Long-lived subscription with observer for real-time updates\nclass OrdersService {\n  Subscription? _subscription;\n  StoreObserver? _observer;\n\n  void initialize() {\n    // Start subscription - keep alive for feature lifetime\n    _subscription = ditto.sync.registerSubscription('SELECT * FROM orders');\n\n    // Use observer for real-time updates\n    _observer = ditto.store.registerObserverWithSignalNext(\n      'SELECT * FROM orders',\n      onChange: (result, signalNext) {\n        updateUI(result.items.map((item) => Order.fromMap(item.value)));\n        signalNext();\n      },\n    );\n  }\n\n  void dispose() {\n    _observer?.cancel();\n    _subscription?.cancel();  // Cancel only when feature is done\n  }\n}",
      "translatedCode": "// ❌ 悪い例: リクエスト/レスポンスパターン（DittoをHTTPのように扱う）\nFuture<List<Order>> fetchOrders() async {\n  final sub = ditto.sync.registerSubscription('SELECT * FROM orders');\n  await Future.delayed(Duration(seconds: 2));  // 非効率的な待機！\n  final result = await ditto.store.execute('SELECT * FROM orders');\n  sub.cancel();  // メッシュ同期の利点を無効化\n  return result.items.map((item) => Order.fromMap(item.value)).toList();\n}\n\n// ✅ 良い例: リアルタイム更新のための長期間のサブスクリプションとオブザーバー\nclass OrdersService {\n  Subscription? _subscription;\n  StoreObserver? _observer;\n\n  void initialize() {\n    // サブスクリプションを開始 - 機能のライフタイムの間維持\n    _subscription = ditto.sync.registerSubscription('SELECT * FROM orders');\n\n    // リアルタイム更新のためにオブザーバーを使用\n    _observer = ditto.store.registerObserverWithSignalNext(\n      'SELECT * FROM orders',\n      onChange: (result, signalNext) {\n        updateUI(result.items.map((item) => Order.fromMap(item.value)));\n        signalNext();\n      },\n    );\n  }\n\n  void dispose() {\n    _observer?.cancel();\n    _subscription?.cancel();  // 機能が完了したときのみキャンセル\n  }\n}",
      "hasComments": true
    },
    {
      "index": 16,
      "language": "dart",
      "originalCode": "// ❌ BAD: Narrow subscription filter breaks multi-hop relay\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders WHERE priority = :priority',\n  arguments: {'priority': 'high'},\n);\n// Problem: This device won't store/relay low-priority orders to other peers\n\n// ✅ GOOD: Broad subscription + local filter in observer\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders',  // No priority filter - enables relay\n);\n\nfinal observer = ditto.store.registerObserverWithSignalNext(\n  'SELECT * FROM orders WHERE priority = :priority',  // Filter here for UI\n  onChange: (result, signalNext) {\n    updateUI(result.items);  // Only high-priority orders displayed\n    signalNext();\n  },\n  arguments: {'priority': 'high'},\n);",
      "translatedCode": "// ❌ 悪い例: 狭いサブスクリプションフィルタがマルチホップリレーを破壊\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders WHERE priority = :priority',\n  arguments: {'priority': 'high'},\n);\n// 問題点: このデバイスは低優先度の注文を保存/リレーしない\n\n// ✅ 良い例: 広いサブスクリプション + オブザーバーでのローカルフィルタ\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders',  // 優先度フィルタなし - リレーを有効化\n);\n\nfinal observer = ditto.store.registerObserverWithSignalNext(\n  'SELECT * FROM orders WHERE priority = :priority',  // UI用にここでフィルタリング\n  onChange: (result, signalNext) {\n    updateUI(result.items);  // 高優先度の注文のみが表示される\n    signalNext();\n  },\n  arguments: {'priority': 'high'},\n);",
      "hasComments": true
    },
    {
      "index": 17,
      "language": "dart",
      "originalCode": "// ❌ BAD: Overly broad subscription when feature only displays current user's data\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders',  // Syncs ALL orders from ALL users!\n);\n\n// ✅ GOOD: Scoped to relevant customer\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders WHERE customerId = :customerId',\n  arguments: {'customerId': currentUserId},\n);\n// Only syncs orders for this customer",
      "translatedCode": "// ❌ 悪い例: 機能が現在のユーザーのデータのみを表示する場合の過度に広いサブスクリプション\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders',  // すべてのユーザーからすべての注文を同期！\n);\n\n// ✅ 良い例: 関連する顧客にスコープ設定\nfinal subscription = ditto.sync.registerSubscription(\n  'SELECT * FROM orders WHERE customerId = :customerId',\n  arguments: {'customerId': currentUserId},\n);\n// この顧客の注文のみを同期",
      "hasComments": true
    },
    {
      "index": 18,
      "language": "dart",
      "originalCode": "// ❌ BAD: No references saved, cannot cancel - memory leak\nclass OrdersScreen extends StatefulWidget {\n  @override\n  State<OrdersScreen> createState() => _OrdersScreenState();\n}\n\nclass _OrdersScreenState extends State<OrdersScreen> {\n  @override\n  void initState() {\n    super.initState();\n    ditto.sync.registerSubscription('SELECT * FROM orders');\n    ditto.store.registerObserverWithSignalNext(\n      'SELECT * FROM orders',\n      onChange: (result, signalNext) { /* ... */ signalNext(); },\n    );\n  }\n}\n\n// ✅ GOOD: Save references and cancel in dispose()\nclass _OrdersScreenState extends State<OrdersScreen> {\n  Subscription? _subscription;\n  StoreObserver? _observer;\n\n  @override\n  void initState() {\n    super.initState();\n    _subscription = ditto.sync.registerSubscription('SELECT * FROM orders');\n    _observer = ditto.store.registerObserverWithSignalNext(\n      'SELECT * FROM orders',\n      onChange: (result, signalNext) { /* ... */ signalNext(); },\n    );\n  }\n\n  @override\n  void dispose() {\n    _observer?.cancel();\n    _subscription?.cancel();\n    super.dispose();\n  }\n}",
      "translatedCode": "// ❌ 悪い例: 参照が保存されず、キャンセルできない - メモリリーク\nclass OrdersScreen extends StatefulWidget {\n  @override\n  State<OrdersScreen> createState() => _OrdersScreenState();\n}\n\nclass _OrdersScreenState extends State<OrdersScreen> {\n  @override\n  void initState() {\n    super.initState();\n    ditto.sync.registerSubscription('SELECT * FROM orders');\n    ditto.store.registerObserverWithSignalNext(\n      'SELECT * FROM orders',\n      onChange: (result, signalNext) { /* ... */ signalNext(); },\n    );\n  }\n}\n\n// ✅ 良い例: 参照を保存し、dispose()でキャンセル\nclass _OrdersScreenState extends State<OrdersScreen> {\n  Subscription? _subscription;\n  StoreObserver? _observer;\n\n  @override\n  void initState() {\n    super.initState();\n    _subscription = ditto.sync.registerSubscription('SELECT * FROM orders');\n    _observer = ditto.store.registerObserverWithSignalNext(\n      'SELECT * FROM orders',\n      onChange: (result, signalNext) { /* ... */ signalNext(); },\n    );\n  }\n\n  @override\n  void dispose() {\n    _observer?.cancel();\n    _subscription?.cancel();\n    super.dispose();\n  }\n}",
      "hasComments": true
    },
    {
      "index": 19,
      "language": "dart",
      "originalCode": "// ✅ GOOD: Observer with backpressure control\nfinal observer = ditto.store.registerObserverWithSignalNext(\n  'SELECT * FROM sensor_data WHERE deviceId = :deviceId',\n  arguments: {'deviceId': deviceId},\n  onChange: (result, signalNext) {\n    updateUI(result.items.map((item) => item.value).toList());\n    // Call signalNext() when ready for next batch\n    signalNext();\n  },\n);",
      "translatedCode": "// ✅ 良い例: バックプレッシャー制御付きのオブザーバー\nfinal observer = ditto.store.registerObserverWithSignalNext(\n  'SELECT * FROM sensor_data WHERE deviceId = :deviceId',\n  arguments: {'deviceId': deviceId},\n  onChange: (result, signalNext) {\n    updateUI(result.items.map((item) => item.value).toList());\n    // 次のバッチの準備ができたらsignalNext()を呼び出す\n    signalNext();\n  },\n);",
      "hasComments": true
    },
    {
      "index": 20,
      "language": "dart",
      "originalCode": "// ❌ BAD: Multiple separate operations without atomicity\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order)',\n  arguments: {'order': {'_id': 'o1', 'customerId': 'c1', 'total': 100}},\n);\nawait ditto.store.execute(\n  'UPDATE customers APPLY orderCount PN_INCREMENT BY 1.0 WHERE _id = :id',\n  arguments: {'id': 'c1'},\n);\n// Problem: If second operation fails, order exists but customer count is wrong\n\n// ✅ GOOD: Atomic transaction ensures all-or-nothing execution\nawait ditto.store.transaction(hint: 'create-order', (tx) async {\n  await tx.execute(\n    'INSERT INTO orders DOCUMENTS (:order)',\n    arguments: {'order': {'_id': 'o1', 'customerId': 'c1', 'total': 100}},\n  );\n  await tx.execute(\n    'UPDATE customers APPLY orderCount PN_INCREMENT BY 1.0 WHERE _id = :id',\n    arguments: {'id': 'c1'},\n  );\n});\n// Benefit: Both operations succeed together or both fail, ensuring data consistency",
      "translatedCode": "// ❌ 悪い例: アトミック性のない複数の個別操作\nawait ditto.store.execute(\n  'INSERT INTO orders DOCUMENTS (:order)',\n  arguments: {'order': {'_id': 'o1', 'customerId': 'c1', 'total': 100}},\n);\nawait ditto.store.execute(\n  'UPDATE customers APPLY orderCount PN_INCREMENT BY 1.0 WHERE _id = :id',\n  arguments: {'id': 'c1'},\n);\n// 問題点: 2番目の操作が失敗すると、注文は存在するが顧客カウントが間違っている\n\n// ✅ 良い例: アトミックトランザクションがすべて成功またはすべて失敗を保証\nawait ditto.store.transaction(hint: 'create-order', (tx) async {\n  await tx.execute(\n    'INSERT INTO orders DOCUMENTS (:order)',\n    arguments: {'order': {'_id': 'o1', 'customerId': 'c1', 'total': 100}},\n  );\n  await tx.execute(\n    'UPDATE customers APPLY orderCount PN_INCREMENT BY 1.0 WHERE _id = :id',\n    arguments: {'id': 'c1'},\n  );\n});\n// 利点: 両方の操作が一緒に成功するか、両方とも失敗し、データの一貫性を保証",
      "hasComments": true
    },
    {
      "index": 21,
      "language": "dart",
      "originalCode": "final results = await ditto.store.transaction(\n  (tx) async {\n    // First, get all order IDs for a specific customer\n    final orderIds = (await tx.execute(\n      'SELECT _id FROM orders WHERE customerId = :customerId',\n      arguments: {'customerId': 'c1'},\n    )).items.map((item) => item.value['_id'] as String).toList();\n\n    // Then, fetch full details for each order\n    // Guaranteed to see the same data state as the first query\n    final orderDetails = await tx.execute(\n      'SELECT * FROM orders WHERE _id IN :ids',\n      arguments: {'ids': orderIds},\n    );\n\n    return orderDetails.items;\n  },\n  isReadOnly: true,\n  hint: 'fetch-orders',\n);",
      "translatedCode": "final results = await ditto.store.transaction(\n  (tx) async {\n    // まず、特定の顧客のすべての注文IDを取得\n    final orderIds = (await tx.execute(\n      'SELECT _id FROM orders WHERE customerId = :customerId',\n      arguments: {'customerId': 'c1'},\n    )).items.map((item) => item.value['_id'] as String).toList();\n\n    // 次に、各注文の完全な詳細を取得\n    // 最初のクエリと同じデータ状態を見ることが保証される\n    final orderDetails = await tx.execute(\n      'SELECT * FROM orders WHERE _id IN :ids',\n      arguments: {'ids': orderIds},\n    );\n\n    return orderDetails.items;\n  },\n  isReadOnly: true,\n  hint: 'fetch-orders',\n);",
      "hasComments": true
    },
    {
      "index": 22,
      "language": "dart",
      "originalCode": "// ❌ BAD: Nested read-write transaction causes permanent deadlock\nawait ditto.store.transaction((tx) async {\n  await tx.execute(\n    'INSERT INTO orders DOCUMENTS (:order)',\n    arguments: {'order': {'_id': 'o1', 'total': 100}},\n  );\n\n  // DEADLOCK: Inner transaction waits for outer, outer waits for inner\n  await ditto.store.transaction((innerTx) async {\n    await innerTx.execute(\n      'UPDATE customers APPLY orderCount PN_INCREMENT BY 1.0 WHERE _id = :id',\n      arguments: {'id': 'c1'},\n    );\n  });\n});\n// Result: App freezes permanently, requires force-quit",
      "translatedCode": "// ❌ 悪い例: ネストされた読み書きトランザクションが永続的なデッドロックを引き起こす\nawait ditto.store.transaction((tx) async {\n  await tx.execute(\n    'INSERT INTO orders DOCUMENTS (:order)',\n    arguments: {'order': {'_id': 'o1', 'total': 100}},\n  );\n\n  // デッドロック: 内部トランザクションが外部を待ち、外部が内部を待つ\n  await ditto.store.transaction((innerTx) async {\n    await innerTx.execute(\n      'UPDATE customers APPLY orderCount PN_INCREMENT BY 1.0 WHERE _id = :id',\n      arguments: {'id': 'c1'},\n    );\n  });\n});\n// 結果: アプリが永続的にフリーズし、強制終了が必要",
      "hasComments": true
    }
  ]
}