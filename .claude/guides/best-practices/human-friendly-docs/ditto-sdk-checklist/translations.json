{
  "en": {
    "title": "Ditto SDK Implementation Checklist",
    "completed": "completed",
    "showCode": "Show Code",
    "hideCode": "Hide Code",
    "officialDoc": "Official Doc",
    "whatMeans": "What this means:",
    "whyMatters": "Why this matters:",
    "sections": [
      "<span class=\"section-number\">Section 1:</span> Initialization & API Basics",
      "<span class=\"section-number\">Section 2:</span> Data Modeling Fundamentals",
      "<span class=\"section-number\">Section 3:</span> Write Operations",
      "<span class=\"section-number\">Section 4:</span> Deletion & Storage Lifecycle",
      "<span class=\"section-number\">Section 5:</span> Read Operations & Queries",
      "<span class=\"section-number\">Section 6:</span> Subscriptions & Real-time Sync",
      "<span class=\"section-number\">Section 7:</span> Performance Optimization",
      "<span class=\"section-number\">Section 8:</span> Transactions",
      "<span class=\"section-number\">Section 9:</span> Attachments",
      "<span class=\"section-number\">Section 10:</span> Security",
      "<span class=\"section-number\">Section 11:</span> Observability & Testing"
    ]
  },
  "ja": {
    "title": "Ditto SDK実装チェックリスト",
    "completed": "完了",
    "showCode": "コードを表示",
    "hideCode": "コードを非表示",
    "officialDoc": "公式ドキュメント",
    "whatMeans": "概要:",
    "whyMatters": "解説:",
    "sections": [
      "<span class=\"section-number\">セクション1:</span> 初期化とAPI基礎",
      "<span class=\"section-number\">セクション2:</span> データモデリングの基礎",
      "<span class=\"section-number\">セクション3:</span> 書き込み操作",
      "<span class=\"section-number\">セクション4:</span> 削除とストレージライフサイクル",
      "<span class=\"section-number\">セクション5:</span> 読み取り操作とクエリ",
      "<span class=\"section-number\">セクション6:</span> サブスクリプションとリアルタイム同期",
      "<span class=\"section-number\">セクション7:</span> パフォーマンス最適化",
      "<span class=\"section-number\">セクション8:</span> トランザクション",
      "<span class=\"section-number\">セクション9:</span> 添付ファイル (Attachments)",
      "<span class=\"section-number\">セクション10:</span> セキュリティ",
      "<span class=\"section-number\">セクション11:</span> 可観測性とテスト"
    ],
    "items": [
      "適切な認証モードでDittoを初期化する",
      "Ditto初期化エラーを適切に処理する",
      "DQL API（現行）を使用し、レガシーBuilder APIを使用しない",
      "startSync()の前に必ずALTER SYSTEM SETをawaitする",
      "デバイス間で衝突する可能性のあるIDパターンを避ける",
      "可変データには配列ではなくMAPを使用する",
      "埋め込みと外部キー関係を適切に使い分ける",
      "大きなバイナリデータを直接ドキュメントに保存しない",
      "計算・派生フィールドをドキュメントに保存しない",
      "不要なデータをドキュメントから除外する",
      "ピア間の型安全性のためにDQL Strict Modeを有効化する [SDK 4.11+]",
      "安全な繰り返しINSERTにはON ID CONFLICT DO NOTHINGを使用する",
      "ドキュメント全体の置き換えではなくフィールドレベルのUPDATEを使用する",
      "同じ値でフィールドを不必要に更新しない",
      "効率的なアップサートにはDO UPDATE_LOCAL_DIFFを使用する [SDK 4.12+]",
      "分散カウンターにはCOUNTER型を使用する [SDK 4.14.0+]",
      "計算可能な派生値にはカウンターを使用しない",
      "イベント履歴には配列ではなく個別のドキュメントを使用する",
      "デバイスローカルテンプレートにはINITIAL DOCUMENTSを使用する",
      "Soft-DeleteとDELETEクエリの違いを理解する",
      "（Soft-Delete使用時）広くサブスクライブし、オブザーバー/クエリでフィルタする",
      "（Soft-Delete使用時）古い削除済みドキュメントを定期的にEVICTする",
      "（Soft-Delete使用時）ローカル削除のみにはEVICTを使用する",
      "（Soft-Delete使用時）再同期ループを防ぐためEVICT前にサブスクリプションをキャンセルする",
      "（DELETE使用時）トゥームストーンとTTL動作を理解する",
      "（DELETE使用時）huskedドキュメントとその防止方法を理解する",
      "（DELETE使用時）永久的で不可逆な削除にのみDELETEを使用する",
      "アプリケーションコードではなくクエリでデータをフィルタする",
      "大規模データセットにはクエリ結果のページネーションを使用する",
      "QueryResultItem参照を長期間保持しない",
      "リクエスト/レスポンスパターンではなく長期サブスクリプションを使用する",
      "広くサブスクライブし、オブザーバーでフィルタする（マルチホップリレー用）",
      "不要なデータにサブスクライブしない",
      "不要になったオブザーバーとサブスクリプションをキャンセルする",
      "バックプレッシャー制御にはregisterObserverWithSignalNextを使用する",
      "オブザーバーエラーを適切に処理する",
      "オブザーバーコールバックで重い処理を避ける",
      "選択的クエリにはCREATE INDEXを使用する [SDK 4.12+]",
      "インデックス使用を確認するためにEXPLAINを使用する [SDK 4.12+]",
      "N+1クエリパターン（複数の個別ルックアップ）を避ける",
      "複数の操作をトランザクションでバッチ処理する",
      "一貫性のある複数クエリ読み取りには読み取り専用トランザクションを使用する",
      "読み書きトランザクションをネストしない（デッドロックの原因）",
      "トランザクションは短く集中させる",
      "（Flutter固有）ditto.close()の前に必ず保留中のトランザクションをawaitする",
      "大きなバイナリデータ（画像、動画、ファイル）には添付ファイルを使用する",
      "添付ファイル取得エラーを適切に処理する",
      "添付ファイル取得タイムアウトを適切に設定する",
      "添付ファイルの可用性制約（直接ピアのみ）を理解する",
      "停止した添付ファイル取得のタイムアウト検出を実装する",
      "孤立した添付ファイルトークンを定期的にクリーンアップする",
      "Bluetooth LE転送用の添付ファイルサイズ制限を検討する",
      "本番アプリにはOnlineWithAuthenticationIdentityを使用する",
      "APIキー、トークン、認証情報をコミットしない",
      "適切な認証デリゲートコールバックを実装する",
      "完全オフライン展開にのみSharedKeyIdentityを使用する",
      "アプリケーションコードにSharedKeyをハードコードしない（セキュリティリスク）",
      "Dittoに挿入する前にユーザー入力を検証・サニタイズする",
      "機密データ（PII、パスワード）をDittoドキュメントに保存しない",
      "本番環境では最小ログレベルを有効化する",
      "デバッグ用にシステム情報をクエリする（SDK 4.13+）",
      "可観測性コールバックで同期ヘルスを監視する",
      "プレゼンスを使用して接続ピアを追跡する",
      "オフラインファースト動作をテストする（オフライン時にデータ作成）",
      "複数デバイスの競合シナリオをテストする",
      "削除パターン（Soft-DeleteとDELETE）をテストする",
      "SDK動作ではなくアプリケーション固有のビジネスロジックをテストする",
      "タイムスタンプ精度とクロックドリフト耐性をテストする"
    ],
    "whatMeansSections": [
      "<p><strong data-what-means>概要:</strong> 適切なIDモードを選択する:</p>\n<p>- <strong>開発環境:</strong> <code>OnlinePlaygroundIdentity</code>（テスト専用、アクセス制御なし）</p>\n<p>- <strong>本番環境:</strong> 認証デリゲート付き <code>OnlineWithAuthenticationIdentity</code></p>\n<p>- <strong>エアギャップ/オフライン環境:</strong> <code>SharedKeyIdentity</code>（クラウド同期なし）</p>",
      "<p><strong data-what-means>概要:</strong> <code>Ditto.open()</code>、<code>startSync()</code>、<code>execute()</code> を try-catch ブロックでラップする。無効なライセンス、ネットワーク利用不可、権限問題、またはクエリエラーなどのケースを処理する。</p>",
      "<p><strong data-what-means>概要:</strong> <code>ditto.store.execute('SELECT * FROM collection ...')</code> および関連するDQLメソッドを使用する。<code>ditto.store.collection('name').find()</code> のような非推奨のビルダーAPIは避ける。</p>",
      "<p><strong data-what-means>概要:</strong> <code>DQL_STRICT_MODE</code> などのシステム設定を構成する際は、<code>startSync()</code> や他の操作を呼び出す前に必ず <code>await</code> を使用する。</p>",
      "<p><strong data-what-means>概要:</strong> 複数のデバイスが独立してドキュメントを作成できる場合、連番カウンター、タイムスタンプ、またはデバイスベースのパターンをドキュメントIDに使用しない。グローバルに一意な識別子（UUID v4、ULID）を使用するか、Dittoに自動生成させる。複合キー（例: <code>{\"userId\": \"user123\", \"orderId\": \"&lt;uuid&gt;\"}</code>）は、その組み合わせが一意であることが保証されている場合に許容される。</p>",
      "<p><strong data-what-means>概要:</strong> 配列はLast-Write-Wins（REGISTER CRDT）を使用するため、複数のピアが同時に更新するとマージ競合が発生する。複数のデバイスで変更可能なデータには、一意のキーを持つMAP（オブジェクト）構造を使用する。</p>",
      "<p><strong data-what-means>概要:</strong> 関連データを単一のドキュメントに埋め込むか、外部キー参照で別のドキュメントにするかを決定する:</p>\n<p><strong>埋め込み（非正規化）:</strong></p>\n<p>- 関連データを親ドキュメント内に直接保存</p>\n<p>- すべてのデータを取得するのに単一のクエリが必要</p>\n<p>- ドキュメント間でデータ重複（複数の注文に同じ顧客情報）</p>\n<p>- すべての関連データが単一のユニットとして同期</p>\n<p>- 最適な用途: 一緒に取得される小さな静的データ（注文品目、住所付きユーザープロフィール）</p>\n<p><strong>外部キー（正規化）:</strong></p>\n<p>- 関連データを別のドキュメントに保存、IDで参照</p>\n<p>- 複数の連続したクエリが必要（DittoはJOINをサポートしていない）</p>\n<p>- データ重複なし、単一の情報源</p>\n<p>- 関連データが独立して同期</p>\n<p>- 最適な用途: 大きなデータ、頻繁に更新されるデータ、または独立してアクセスされるデータ（ユーザープロフィール、製品カタログ）</p>",
      "<p><strong data-what-means>概要:</strong> 画像、動画、または大きなファイルをbase64文字列としてドキュメントフィールドに保存しない。代わりにDitto添付ファイルを使用する。</p>",
      "<p><strong data-what-means>概要:</strong> 既存のデータから計算できるフィールド（例: <code>lineTotal = price × quantity</code>、<code>subtotal = sum(items)</code>、<code>total = subtotal + tax</code>）を保存しない。必要なときにアプリケーションコードでこれらの値を計算する。</p>",
      "<p><strong data-what-means>概要:</strong> Dittoドキュメントのすべてのフィールドは、メッシュネットワーク内のすべてのピアに同期され、帯域幅とストレージを消費する。デバイス間で必要な共有ビジネス状態を表すデータのみを含める。同期しないもの:</p>\n<p>- <strong>UI固有の状態:</strong> 展開/選択/ホバー状態、スクロール位置、アクティブなタブインデックス</p>\n<p>- <strong>一時的/過渡的な状態:</strong> アップロード進行状況、処理フラグ、再試行カウンター、ローディングインジケーター</p>\n<p>- <strong>デバイス固有のデータ:</strong> ローカルファイルパス、デバイスID（認可に必要でない限り）、デバイス機能</p>\n<p>- <strong>キャッシュ/派生データ:</strong> 他のフィールドから計算できる値または外部ソースから取得できる値</p>\n<p>- <strong>高頻度の短命データ:</strong> マウスカーソル位置、タイピングインジケーター、永続化不要なリアルタイムセンサー読み取り</p>\n<p>- <strong>デバッグ/開発データ:</strong> テストフラグ、デバッグカウンター、開発専用メタデータ</p>",
      "<p><strong data-what-means>概要:</strong> ピア間での型の一貫性を強制するためにDQL Strict Modeを有効化する [SDK 4.11+]</p>",
      "<p><strong data-what-means>概要:</strong> 安全な繰り返しINSERTには <code>ON ID CONFLICT DO NOTHING</code> を使用する</p>",
      "<p><strong data-what-means>概要:</strong> ドキュメント全体を置き換える代わりに、<code>UPDATE</code> を使用して特定のフィールドのみを変更する</p>",
      "<p><strong data-what-means>概要:</strong> 既に同じ値を持つフィールドを更新しない（不要な同期トラフィックを回避）</p>",
      "<p><strong data-what-means>概要:</strong> 効率的なアップサート（存在しない場合は挿入、存在する場合は更新）には <code>DO UPDATE_LOCAL_DIFF</code> を使用する [SDK 4.12+]</p>",
      "<p><strong data-what-means>概要:</strong> 分散カウンター（在庫数量、いいね数など）には <code>COUNTER</code> 型を使用する [SDK 4.14.0+]</p>",
      "<p><strong data-what-means>概要:</strong> 計算可能な派生値（合計、平均など）にはカウンターを使用しない</p>",
      "<p><strong data-what-means>概要:</strong> イベント履歴やログには配列ではなく個別のドキュメントを使用する</p>",
      "<p><strong data-what-means>概要:</strong> デバイスローカルテンプレートには <code>INITIAL DOCUMENTS</code> を使用する</p>",
      "<p><strong data-what-means>概要:</strong> Soft-Delete（論理削除）とDELETEクエリ（物理削除）の違いを理解する</p>",
      "<p><strong data-what-means>概要:</strong> （Soft-Delete使用時）広くサブスクライブし、オブザーバー/クエリでフィルタする</p>",
      "<p><strong data-what-means>概要:</strong> （Soft-Delete使用時）ストレージを解放するため、古い削除済みドキュメントを定期的にEVICTする</p>",
      "<p><strong data-what-means>概要:</strong> （Soft-Delete使用時）ローカルデバイスからのみドキュメントを削除し、他のピアには伝播させない場合は <code>EVICT</code> を使用する</p>",
      "<p><strong data-what-means>概要:</strong> （Soft-Delete使用時）EVICT前にサブスクリプションをキャンセルして再同期ループを防ぐ</p>",
      "<p><strong data-what-means>概要:</strong> （DELETE使用時）トゥームストーン（削除マーカー）とTTL（Time To Live）動作を理解する</p>",
      "<p><strong data-what-means>概要:</strong> （DELETE使用時）huskedドキュメント（DELETEとUPDATEの同時実行による）とその防止方法を理解する</p>",
      "<p><strong data-what-means>概要:</strong> （DELETE使用時）永久的で不可逆な削除にのみ <code>DELETE</code> を使用する</p>",
      "<p><strong data-what-means>概要:</strong> アプリケーションコードで結果をフィルタするのではなく、DQLクエリの <code>WHERE</code> 句でデータをフィルタする</p>",
      "<p><strong data-what-means>概要:</strong> 大規模データセット（>1000行）にはクエリ結果のページネーションを使用する</p>",
      "<p><strong data-what-means>概要:</strong> <code>QueryResultItem</code> オブジェクトへの参照を長期間保持しない</p>",
      "<p><strong data-what-means>概要:</strong> リクエスト/レスポンスパターンではなく長期サブスクリプションを使用する</p>",
      "<p><strong data-what-means>概要:</strong> マルチホップリレーを確実にするため、広くサブスクライブし（フィルタなしまたは緩いフィルタ）、オブザーバーで厳密にフィルタする</p>",
      "<p><strong data-what-means>概要:</strong> 不要なデータにサブスクライブしない（不要な同期トラフィックを回避）</p>",
      "<p><strong data-what-means>概要:</strong> 画面を離れるとき、コンポーネントを破棄するとき、またはデータが不要になったときに、オブザーバーとサブスクリプションをキャンセルする</p>",
      "<p><strong data-what-means>概要:</strong> バックプレッシャー制御には <code>registerObserverWithSignalNext</code> を使用する</p>",
      "<p><strong data-what-means>概要:</strong> オブザーバーコールバック内で発生するエラーを適切に処理する</p>",
      "<p><strong data-what-means>概要:</strong> オブザーバーコールバック内で重い処理（大規模なデータ変換、同期API呼び出し、ファイルI/Oなど）を実行しない</p>",
      "<p><strong data-what-means>概要:</strong> 選択的クエリ（特定の値やフィールド範囲でフィルタリング）には <code>CREATE INDEX</code> を使用する [SDK 4.12+]</p>",
      "<p><strong data-what-means>概要:</strong> <code>EXPLAIN</code> を使用してクエリがインデックスを使用しているか、フルコレクションスキャンを実行しているかを確認する [SDK 4.12+]</p>",
      "<p><strong data-what-means>概要:</strong> N+1クエリパターン（ループ内で個別のクエリを実行）を避ける</p>",
      "<p><strong data-what-means>概要:</strong> 複数の操作（INSERT、UPDATE、DELETE）を単一のトランザクションにバッチ処理する</p>",
      "<p><strong data-what-means>概要:</strong> 一貫性のある複数クエリ読み取りには読み取り専用トランザクションを使用する</p>",
      "<p><strong data-what-means>概要:</strong> 読み書きトランザクションをネストしない（デッドロックの原因となる）</p>",
      "<p><strong data-what-means>概要:</strong> トランザクション内の操作数と実行時間を最小限に抑える。重い計算、ネットワーク呼び出し、または長時間実行されるロジックを避ける。</p>",
      "<p><strong data-what-means>概要:</strong> （Flutter固有）Flutter SDKでは、<code>ditto.close()</code> を呼び出す前にすべての保留中のトランザクションを追跡し、<code>await Future.wait(pendingTransactions)</code> を使用する。他のプラットフォームとは異なり、Flutter SDKは自動的にトランザクションを待機しない。</p>",
      "<p><strong data-what-means>概要:</strong> 大きなバイナリデータ（通常 >100KB）をドキュメントフィールドにbase64文字列として保存しない。Ditto添付ファイルとして保存し、ドキュメントフィールドに添付ファイルトークンを保存してバイナリデータを参照する。</p>",
      "<p><strong data-what-means>概要:</strong> <code>fetchAttachment()</code> を try-catch ブロックでラップして、ピアの利用不可、ネットワークタイムアウト、または破損データなどのケースを処理する</p>",
      "<p><strong data-what-means>概要:</strong> <code>fetchAttachment()</code> のタイムアウトパラメータを使用して、遅いまたは利用できないピアの待機時間を制限する: <code>fetchAttachment(token, timeout: Duration(seconds: 30))</code></p>",
      "<p><strong data-what-means>概要:</strong> 添付ファイルは、既に添付ファイルを取得した<strong>直接ピア</strong>（直接接続されたデバイス）からのみ取得できる。デバイスAが添付ファイルを持ち、デバイスCがそれを必要とするマルチホップシナリオでは、デバイスB（中間）がまだ取得していない場合、デバイスCはデバイスAから取得できない。</p>",
      "<p><strong data-what-means>概要:</strong> Dittoの添付ファイル取得は、接続が停止したときにエラーを発生させない。単に進行が停止するだけ。進行監視ラッパーを実装して、タイムアウト期間（例: 5分）内に進行がないことを検出する。</p>",
      "<p><strong data-what-means>概要:</strong> 添付ファイルを含むドキュメントを削除するときは、添付ファイル参照の削除を検討する。対応するドキュメントのない添付ファイルトークンを定期的にスキャンする。</p>",
      "<p><strong data-what-means>概要:</strong> Bluetooth LEトランスポートに依存するモバイルデバイスでは、添付ファイルサイズを制限する（例: 画像は &lt;5MB、より大きなものにはサムネイルを使用）。Bluetooth経由での同期パフォーマンスをテストする。</p>",
      "<p><strong data-what-means>概要:</strong> <code>OnlineWithAuthenticationIdentity</code> でDittoを構成し、認証デリゲートを実装して認証システム（OAuth、JWT、カスタム）と統合する</p>",
      "<p><strong data-what-means>概要:</strong> Ditto App ID、認証トークン、APIキーには環境変数または安全なストレージを使用する。それらをハードコードしたり、バージョン管理にコミットしたりしない。</p>",
      "<p><strong data-what-means>概要:</strong> <code>onAuthenticationExpiringSoon()</code> および <code>onAuthenticationRequired()</code> コールバックを実装して、有効期限前にトークンを更新し、再認証を促す</p>",
      "<p><strong data-what-means>概要:</strong> <code>SharedKeyIdentity</code>（オフラインモード）はクラウド同期を無効にし、メッシュ認証に共有シークレットを使用する。クラウド接続が利用できない場合にのみ使用する。</p>",
      "<p><strong data-what-means>概要:</strong> <code>SharedKey</code> の値をモバイルアプリのソースコードに直接ハードコードしない。MDM（モバイルデバイス管理）を使用して安全な鍵配布を行うか、ランタイムプロビジョニングを伴うプラットフォーム固有の安全なストレージを使用する。</p>",
      "<p><strong data-what-means>概要:</strong> Dittoに挿入する前にユーザー入力を検証およびサニタイズする</p>",
      "<p><strong data-what-means>概要:</strong> PII、パスワード、またはトークンなどの機密データをDittoドキュメントに保存しない</p>",
      "<p><strong data-what-means>概要:</strong> 本番環境では最小ログレベル（WARNING または ERROR）を有効化する</p>",
      "<p><strong data-what-means>概要:</strong> <code>SELECT * FROM %%SYSTEM_INFO%%</code> を使用してデバッグ用のシステム情報をクエリする（SDK 4.13+）</p>",
      "<p><strong data-what-means>概要:</strong> 可観測性コールバックを使用して同期ヘルスを監視する</p>",
      "<p><strong data-what-means>概要:</strong> プレゼンスを使用して接続ピアを追跡する</p>",
      "<p><strong data-what-means>概要:</strong> オフラインファースト動作（オフライン時にデータを作成）をテストする</p>",
      "<p><strong data-what-means>概要:</strong> 複数のDittoインスタンスから同じドキュメントへの同時変更をシミュレートするテストを作成し、同期後のCRDTマージ動作を検証する</p>",
      "<p><strong data-what-means>概要:</strong> 削除パターン（Soft-DeleteとDELETE）をテストする</p>",
      "<p><strong data-what-means>概要:</strong> <strong>アプリケーションのビジネスロジックとデータモデル</strong>を同時シナリオ下で検証するテストを作成する</p>",
      "<p><strong data-what-means>概要:</strong> デバイスのクロックがずれている（例: デバイスAは5秒進んでいる、デバイスBは3秒遅れている）状況をシミュレートするテストを作成する。タイムスタンプベースのロジックが適切な許容範囲でクロックドリフトを処理することを検証する。</p>"
    ],
    "whyMattersSections": [
      "<p>認証モードは、セキュリティモデルと同期機能を決定します。OnlinePlaygroundは本番環境では安全ではありません。OnlineWithAuthenticationは適切なアクセス制御を提供します。SharedKeyは完全にオフラインでの展開用です。</p>",
      "<p>Dittoの初期化と操作は、ライセンス、ネットワーク、プラットフォームの問題、または無効なクエリにより失敗する可能性があります。適切なエラーハンドリングは、アプリのクラッシュを防ぎ、ユーザーにフィードバックを提供します。</p>",
      "<p>Builder APIは非推奨であり、トランザクション、最適化、およびv5との前方互換性などの機能が欠けています。DQL APIは現在の標準（SDK 4.12+）であり、今後も保守されます。</p>",
      "<p><code>store.execute()</code>は非同期です。awaitせずに処理を進めると、同期が開始される前に設定が適用されず、ピア間で一貫性のない動作を引き起こす可能性があります。</p>",
      "<p>連番IDの生成は、複数のオフラインデバイスが同じIDパターンでドキュメントを作成する際に衝突を引き起こします（例: \"order_001\"）。衝突は競合解決をトリガーし、データ損失や予期しない動作を引き起こす可能性があります。複合キーを使用する認可パターン（例: <code>{\"userId\": \"user123\", \"resourceId\": \"&lt;uuid&gt;\"}</code>）では、少なくとも1つのコンポーネントがグローバルに一意であることを確認してください。</p>",
      "<p>オフラインピアからの同時配列更新は、同期後にデータ損失、重複、または不整合な状態を引き起こします。MAP構造は「追加が勝つ」セマンティクスを使用し、異なるキーへの同時更新を競合なしで自動的にマージします。</p>",
      "<p>DittoはSQL形式のJOINをサポートしていません。埋め込みデータの場合、1つのクエリですべてを取得できますが、ドキュメント間でデータが重複します。外部キーの場合、複数の連続クエリが必要（N+1パターンのリスク）ですが、単一の情報源を維持します。選択基準: (1) データがどのように一緒にアクセスされるか、(2) 更新頻度、(3) データサイズ、(4) 許容可能な重複のトレードオフ。埋め込みデータは、書き込みオーバーヘッドとストレージを犠牲にして読み取りパフォーマンスを最適化します。外部キーは、複数クエリを犠牲にして書き込みパフォーマンスとストレージを最適化します。</p>",
      "<p>ドキュメント内の大きなバイナリデータは、同期トラフィックとストレージを肥大化させます。添付ファイルは遅延ロードされ、オンデマンドで取得されるため、帯域幅とストレージを最適化します。</p>",
      "<p>計算フィールドを保存すると、帯域幅の無駄（不要なデータの同期）、古いデータのリスク（ソースが変更されても計算フィールドが更新されない）、および同期オーバーヘッドの追加が発生します。代わりにオンデマンドで計算してください。</p>",
      "<p>不要なデータの同期は、ネットワーク帯域幅の無駄（従量制接続では重要）、バッテリーの消耗（継続的な同期）、すべてのデバイスでのストレージの肥大化、および重要なビジネスデータの同期パフォーマンスの低下を引き起こします。すべてのピアは、このデータを保存、処理、中継する必要がありますが、その多くは単一のデバイスまたは瞬間にのみ関連します。</p><p><strong>重要な原則:</strong> デバイス間で必要な<strong>ビジネス状態</strong>（「単一の情報源」）のみを同期し、<strong>プレゼンテーション状態</strong>（UIがデータを表示する方法）、<strong>一時的な状態</strong>（一時的な処理ステータス）、または<strong>デバイスローカルな状態</strong>（1つのデバイスの環境に固有）は同期しないでください。</p>",
      "<p>DQL Strict Modeは、ピア間での型の一貫性を強制し、型の不一致によるランタイムエラーやクエリの失敗を防ぎます。厳密モードがない場合、1つのピアが文字列を挿入し、別のピアが数値を挿入すると、予期しない動作を引き起こす可能性があります。</p>",
      "<p><code>ON ID CONFLICT DO NOTHING</code>は、ドキュメントが既に存在する場合にエラーをスローせずに、安全に繰り返しINSERTを実行できます。これは、複数回実行される可能性のある冪等操作（リトライロジック、バックグラウンド同期）に役立ちます。</p>",
      "<p>フィールドレベルのUPDATEは、変更されたフィールドのみを同期し、帯域幅とストレージを節約します。ドキュメント全体の置き換え（再挿入）は、変更されていないフィールドも含めすべてのフィールドを同期し、不要なトラフィックを生成します。</p>",
      "<p>同じ値でフィールドを更新すると、不要な同期トラフィックが生成され、変更がないにもかかわらずすべてのピアに更新が伝播されます。更新前に値が実際に変更されたかどうかを確認してください。</p>",
      "<p><code>DO UPDATE_LOCAL_DIFF</code>は、ドキュメントが存在しない場合は挿入し、存在する場合は変更されたフィールドのみを更新する効率的なアップサート操作です。これにより、帯域幅とストレージが最適化されます。</p>",
      "<p>COUNTER型は、複数のピアが同時に値を増減できる分散カウンター（CvRDT）を提供します。すべての増減は自動的にマージされ、最終的な一貫性が保証されます。通常の数値フィールドは最後の書き込みが勝ち、同時更新により失われたインクリメントが発生する可能性があります。</p>",
      "<p>派生値（合計、平均など）にカウンターを使用すると、ソースデータが変更されたときに更新が複雑になります。代わりに、ソースデータを保存し、派生値をアプリケーションコードでオンデマンドで計算してください。</p>",
      "<p>イベントを配列に追加すると、同時更新時にマージ競合が発生します（Last-Write-Winsセマンティクス）。個別のドキュメントとして各イベントを保存すると、自動マージが可能になり、イベント履歴の独立したクエリとページネーションが可能になります。</p>",
      "<p><code>INITIAL DOCUMENTS</code>は、コレクションが空の場合にのみローカルデバイスにドキュメントを挿入します。これは、他のピアに同期されないデバイス固有のテンプレートまたはデフォルト設定に役立ちます。</p>",
      "<p>Soft-Delete（論理削除: <code>isDeleted</code>フラグを設定）は、削除をすべてのピアに伝播し、監査証跡を保持し、復元を可能にします。DELETEクエリ（物理削除）は、ドキュメントを永久に削除し、トゥームストーンを作成してTTL期間後に削除します。両者の違いを理解することは、データライフサイクル管理に不可欠です。</p>",
      "<p>マルチホップリレーを確実にするため、広くサブスクライブし（<code>isDeleted IS NULL OR isDeleted = false</code>ではなく<code>SELECT * FROM collection</code>）、オブザーバー/クエリでフィルタします。これにより、論理削除されたドキュメントが中間ピアを通じて伝播されます。</p>",
      "<p>論理削除されたドキュメントは、ストレージを消費し、クエリパフォーマンスに影響を与えます。古い削除済みドキュメント（例: 30日以上前）を定期的にEVICTして、ディスク使用量を管理し、クエリ速度を維持します。</p>",
      "<p><code>EVICT</code>は、ローカルデバイスからのみドキュメントを削除し、削除を他のピアに伝播しません。これは、ストレージをクリーンアップする必要があるが、削除をネットワーク全体にブロードキャストしたくない場合に役立ちます。</p>",
      "<p>アクティブなサブスクリプション中にドキュメントをEVICTすると、サブスクリプションがピアから再同期し、再びEVICTするという再同期ループが発生します。EVICT前にサブスクリプションをキャンセルして、この無限ループを防ぎます。</p>",
      "<p>トゥームストーン（削除マーカー）は、ピア間で削除を伝播するために作成されます。トゥームストーンはTTL期間（デフォルト: 30日）後に期限切れになります。TTL期間中にオンラインにならなかったピアは、削除されたドキュメントを再同期する可能性があります。</p>",
      "<p>Huskedドキュメントは、DELETEとUPDATEが同時に発生したときに発生します。DELETEはドキュメントを削除しますが、UPDATEは変更されたフィールドのみで新しいドキュメントを作成し、意図しない部分的なドキュメントを残します。Huskedドキュメントを防ぐには、DELETEの前にサブスクリプションをキャンセルし、UPDATEの前に存在チェックを実行します。</p>",
      "<p>DELETEクエリは永久的で不可逆です（トゥームストーンTTL後）。監査、復元、または履歴追跡が必要な場合は、代わりにSoft-Deleteを使用してください。</p>",
      "<p>DQLクエリの<code>WHERE</code>句でフィルタすることにより、ネットワークから関連データのみを取得し、帯域幅、メモリ使用量、処理時間を削減します。アプリケーションコードでのフィルタは、不要なデータを取得して破棄します。</p>",
      "<p>大規模データセット（>1000行）の場合、ページネーション（<code>LIMIT</code>と<code>OFFSET</code>）を使用してメモリ使用量を削減し、応答性を向上させます。すべてのデータを一度に読み込むと、メモリ不足やUI凍結を引き起こす可能性があります。</p>",
      "<p><code>QueryResultItem</code>オブジェクトは、内部ストレージ状態への参照を保持する場合があります。長期間保持すると、メモリリークや古いデータを引き起こす可能性があります。代わりに、<code>QueryResultItem</code>から必要なデータ（プレーンなDart/Swiftオブジェクト）を抽出し、その抽出されたデータを保持します。</p>",
      "<p>リクエスト/レスポンスパターン（定期的なポーリング、繰り返しクエリ）は、不要な帯域幅、バッテリー、処理を浪費します。長期サブスクリプションは、変更をリアルタイムでプッシュし、帯域幅とバッテリー使用量を最適化します。</p>",
      "<p>マルチホップリレーを確実にするため、広くサブスクライブし（<code>isActive = true</code>ではなく<code>SELECT * FROM collection</code>）、オブザーバーで厳密にフィルタします。これにより、中間ピアがデータを中継できます。</p>",
      "<p>不要なデータにサブスクライブすると、不要な同期トラフィック、ストレージ消費、およびオブザーバーの実行が発生します。必要なデータのみにサブスクライブしてください。</p>",
      "<p>オブザーバーとサブスクリプションをキャンセルしないと、メモリリーク、不要な同期トラフィック、およびバックグラウンドでのオブザーバーコールバックの実行が発生します。不要になったら必ずキャンセルしてください。</p>",
      "<p><code>registerObserverWithSignalNext</code>は、バックプレッシャー制御を提供し、前のイベントの処理が完了するまでオブザーバーが次のイベントを受信しないようにします。これにより、高速更新時のメモリ枯渇や処理遅延を防ぎます。</p>",
      "<p>オブザーバーコールバック内のエラーは、アプリのクラッシュ、サイレント失敗、または不整合な状態を引き起こす可能性があります。オブザーバー内に適切なエラーハンドリングを実装して、エラーをキャッチしてログに記録します。</p>",
      "<p>オブザーバーコールバック内で重い処理を実行すると、UIがブロックされ、オブザーバーキューがバックアップされ、応答性が低下します。重い処理はバックグラウンドスレッド/isolateにオフロードしてください。</p>",
      "<p>インデックスは、フルコレクションスキャンを回避することでクエリパフォーマンスを大幅に向上させます。インデックスがない場合、Dittoは一致するドキュメントを見つけるためにすべてのドキュメントをスキャンする必要があります。インデックスは、頻繁にクエリされるフィールド（<code>WHERE status = 'active'</code>、<code>WHERE userId = '...'</code>）に作成してください。</p>",
      "<p><code>EXPLAIN</code>は、クエリがインデックスを使用しているか（<code>index_scan</code>）、フルコレクションスキャンを実行しているか（<code>table_scan</code>）を示します。<code>table_scan</code>はパフォーマンスボトルネックを示し、インデックスを作成する必要があることを示唆します。</p>",
      "<p>N+1クエリパターン（ループ内で個別のクエリを実行）は、複数のクエリ実行のオーバーヘッドによりパフォーマンスを大幅に低下させます。代わりに、<code>IN</code>句を使用して単一のクエリですべての関連ドキュメントを取得してください。</p>",
      "<p>トランザクションは、複数の操作を単一のアトミックユニットにバッチ処理し、複数の個別クエリのオーバーヘッドを削減します。トランザクションは、すべての操作が成功するか、すべての操作が失敗することを保証し、部分的な更新を防ぎます。</p>",
      "<p>読み取り専用トランザクションは、複数のクエリにわたって一貫したスナップショットを提供し、読み取り中にデータが変更されないことを保証します。トランザクションがない場合、別々のクエリが異なる時点のデータを見る可能性があり、不整合な結果を引き起こします。</p>",
      "<p>ネストされた読み書きトランザクションは、両方のトランザクションが互いのロックを待機してデッドロックを引き起こす可能性があります。ネストされたトランザクションを避け、必要に応じて単一のトランザクションで操作を平坦化してください。</p>",
      "<p>長時間実行されるトランザクションは、ロックを長時間保持し、他の操作をブロックし、パフォーマンスを低下させます。トランザクションを短く集中させ（迅速なデータベース操作のみ）、重い計算やネットワーク呼び出しをトランザクションの外に移動してください。</p>",
      "<p>Flutter SDKでは、<code>ditto.close()</code>を呼び出す前にすべての保留中のトランザクションを<code>await</code>する必要があります。そうしないと、トランザクションが中断され、部分的な更新やデータ不整合が発生する可能性があります。他のプラットフォームのSDKは自動的に待機しますが、Flutter SDKは手動で管理する必要があります。</p>",
      "<p>ドキュメント内の大きなバイナリデータ（画像、動画、ファイル）は、同期トラフィックとストレージを肥大化させます。添付ファイルは、必要なときにのみオンデマンドで取得されるため、帯域幅とストレージを最適化します。ドキュメントは軽量な添付ファイルトークン（小さな参照）のみを保存します。</p>",
      "<p>添付ファイルの取得は、ピアの利用不可、ネットワークタイムアウト、または破損データにより失敗する可能性があります。適切なエラーハンドリング（try-catch、リトライロジック、ユーザーフィードバック）は、アプリのクラッシュを防ぎ、より良いユーザー体験を提供します。</p>",
      "<p>タイムアウトがない場合、<code>fetchAttachment()</code>は、遅いまたは利用できないピアを無期限に待機する可能性があります。タイムアウトを設定すると、応答性が保証され、ユーザーがフォールバック動作（キャッシュされた画像の表示、リトライのプロンプト）を実装できます。</p>",
      "<p>添付ファイルは、既に添付ファイルを持っている直接ピア（直接接続されたデバイス）からのみ取得できます。マルチホップシナリオでは、中間ピアが添付ファイルを取得していない場合、エンドピアは添付ファイルを取得できません。これにより、添付ファイルの可用性が制限されます。</p>",
      "<p>Dittoの添付ファイル取得は、接続が停止したときにエラーを発生させません。単に進行が停止するだけです。進行監視ラッパーを実装して、タイムアウト期間（例: 5分）内に進行がないことを検出し、適切にエラーをスローします。</p>",
      "<p>ドキュメントが削除された後も添付ファイルは残ります。対応するドキュメントのない孤立した添付ファイルトークンは、ストレージを無駄に消費します。定期的にスキャンしてクリーンアップし、ディスク使用量を管理します。</p>",
      "<p>Bluetooth LEトランスポートは、Wi-FiやLANよりも帯域幅が大幅に低いです。大きな添付ファイルは、同期を遅くしたり、タイムアウトを引き起こしたりする可能性があります。添付ファイルサイズを制限し（例: &lt;5MB）、より大きなものにはサムネイルまたは圧縮を使用し、Bluetooth経由で同期パフォーマンスをテストします。</p>",
      "<p><code>OnlineWithAuthenticationIdentity</code>は、認証システム（OAuth、JWT、カスタム）との統合を可能にし、適切なアクセス制御を提供し、大規模同期のためにBig Peer（クラウドデプロイメント）を有効にします。これは、すべての本番アプリケーションに推奨されるIDモードです。</p>",
      "<p>APIキー、トークン、または認証情報をハードコードまたはバージョン管理にコミットすると、深刻なセキュリティリスクが発生します。環境変数または安全なストレージを使用して、認証情報がソースコードで公開されないようにします。</p>",
      "<p>認証デリゲートコールバックは、トークンのライフサイクルを管理します。<code>onAuthenticationExpiringSoon()</code>は、有効期限前にトークンを更新し、<code>onAuthenticationRequired()</code>は、トークンが無効になったときに再認証を処理します。これらのコールバックがないと、トークンの有効期限によりユーザーが予期せず切断される可能性があります。</p>",
      "<p><code>SharedKeyIdentity</code>は、クラウド同期を無効にし、メッシュ認証に共有シークレットを使用します。これは、クラウド接続が利用できない完全にオフラインの展開（例: 軍事、産業、エアギャップ環境）専用です。</p>",
      "<p>モバイルアプリのソースコードに<code>SharedKey</code>の値をハードコードすると、深刻なセキュリティリスクが発生します。攻撃者がアプリを逆コンパイルしてキーを抽出し、メッシュネットワークへの不正アクセスを取得する可能性があります。MDMまたはプラットフォーム固有の安全なストレージを使用して安全な鍵配布を行います。</p>",
      "<p>サニタイズされていないユーザー入力は、インジェクション攻撃、予期しないデータ型、または無効なデータを引き起こす可能性があります。Dittoに挿入する前に入力を検証およびサニタイズして、データ整合性を確保します。</p>",
      "<p>Dittoドキュメントは、メッシュネットワーク内のすべてのピアに同期されます。PII、パスワード、またはトークンなどの機密データを保存すると、不正アクセスやコンプライアンス違反のリスクが発生します。機密データには専用の安全なストレージを使用してください。</p>",
      "<p>詳細なロギング（DEBUG、VERBOSE）は、本番環境で機密データ（ユーザーID、ドキュメントコンテンツ）を公開し、パフォーマンスを低下させる可能性があります。本番環境では最小ログレベル（WARNING、ERROR）を使用して、重要な問題のみをログに記録します。</p>",
      "<p><code>SELECT * FROM %%SYSTEM_INFO%%</code>は、アクティブなサブスクリプション、ストレージサイズ、同期状態などのシステムメタデータをクエリします。この情報は、同期の問題のデバッグ、パフォーマンスの監視、およびシステムヘルスの理解に役立ちます。</p>",
      "<p>可観測性コールバック（<code>onTransportConditionChange</code>、<code>onConnectionChange</code>）は、同期ヘルス、接続状態、およびトランスポートステータスへの可視性を提供します。これらのコールバックを監視することで、同期の問題を積極的に検出して対処できます。</p>",
      "<p>プレゼンスは、接続されたピア、そのオンライン/オフラインステータス、およびメタデータ（デバイスタイプ、ユーザー名）を追跡します。プレゼンスは、コラボレーション機能（\"誰がオンライン\"）、接続診断、およびピアの可用性の理解に役立ちます。</p>",
      "<p>オフラインファースト動作は、Dittoアプリの基本原則です。オフライン時にデータを作成し、デバイスが再接続したときに同期されることを検証することで、アプリがオフライン条件下で正しく機能することを保証します。</p>",
      "<p>複数のデバイスからの同時変更をテストすることで、CRDT競合解決が正しく機能することを検証します。これにより、データ損失、予期しないマージ、または不整合な状態が発生しないことを保証します。</p>",
      "<p>削除パターン（Soft-DeleteおよびDELETE）をテストすることで、削除がすべてのピアに正しく伝播され、古いドキュメントがクリーンアップされ、huskedドキュメントが発生しないことを検証します。</p>",
      "<p>Dittoは、CRDTマージ、同期、およびトランスポートを処理します。これらをテストする必要はありません。代わりに、同時シナリオ下でのアプリケーションのビジネスロジックとデータモデルに焦点を当ててください（例: 2つのユーザーが同じ注文を同時に更新した場合、アプリのロジックは正しい最終状態を生成しますか？）。</p>",
      "<p>Dittoの同期は、Hybrid Logical Clocks（HLC）を使用して因果順序を決定します。HLCはクロックドリフトに耐性がありますが、アプリケーションレベルのタイムスタンプロジック（例: 「最新のイベントを表示」、タイムスタンプによるフィルタリング）は、個別のデバイスクロックに依存します。妥当な許容範囲（例: ±5秒）でクロックドリフトを処理することをテストして、ユーザー体験が壊れないようにします。</p>"
    ]
  }
}