// ============================================================================
// ID Generation Patterns for Distributed Systems
// ============================================================================
//
// CRITICAL: Sequential IDs cause collisions in distributed P2P systems
//
// PATTERNS DEMONSTRATED:
// 1. ‚úÖ UUID v4 (RECOMMENDED - general-purpose)
// 2. ‚úÖ Auto-Generated (SIMPLEST - omit _id)
// 3. ‚úÖ Composite Keys (ADVANCED - permission scoping)
// 4. ‚úÖ ULID (TIME-ORDERED - chronological sorting)
// 5. ‚ùå Sequential IDs (ANTI-PATTERN - collision risk)
// 6. ‚úÖ Human-Readable Display (UUID + display fields)
// 7. ‚úÖ Migration from Sequential IDs (dual-write pattern)
//
// ============================================================================

import 'dart:math';

import 'package:dittolive_ditto/dittolive_ditto.dart';
import 'package:uuid/uuid.dart';

// ============================================================================
// Pattern 1: UUID v4 (RECOMMENDED)
// ============================================================================

/// ‚úÖ GOOD: UUID v4 provides collision-free IDs for distributed systems
Future<void> uuidV4Pattern(Ditto ditto) async {
  print('‚úÖ Pattern 1: UUID v4 (RECOMMENDED)\n');

  final uuid = Uuid();
  final orderId = uuid.v4(); // "7c0c20ed-b285-48a6-80cd-6dcf06d52bcc"

  await ditto.store.execute(
    'INSERT INTO orders DOCUMENTS (:order)',
    arguments: {
      'order': {
        '_id': orderId,
        'orderNumber': '#42',
        'status': 'pending',
        'createdAt': DateTime.now().toIso8601String(),
      }
    },
  );

  print('‚úÖ Created order with UUID v4: $orderId');
  print('   - Collision-free (~1 in 2^61 for 1 billion IDs)');
  print('   - No device coordination required');
  print('   - Aligns with Ditto\'s native auto-generated IDs');
  print('   - Platform-agnostic (works on all platforms)');
}

// ============================================================================
// Pattern 2: Auto-Generated (SIMPLEST)
// ============================================================================

/// ‚úÖ GOOD: Omit _id to let Ditto auto-generate UUID (simplest approach)
Future<void> autoGeneratedPattern(Ditto ditto) async {
  print('\n‚úÖ Pattern 2: Auto-Generated (SIMPLEST)\n');

  // Omit _id - Ditto auto-generates 128-bit UUID
  await ditto.store.execute(
    'INSERT INTO orders DOCUMENTS (:order)',
    arguments: {
      'order': {
        // No _id field - Ditto generates UUID automatically
        'orderNumber': '#43',
        'status': 'pending',
        'createdAt': DateTime.now().toIso8601String(),
      }
    },
  );

  print('‚úÖ Created order with auto-generated ID');
  print('   - Simplest approach (no code needed)');
  print('   - Ditto generates 128-bit UUID automatically');
  print('   - Collision-free and distributed-safe');
}

// ============================================================================
// Pattern 3: Composite Keys (ADVANCED)
// ============================================================================

/// ‚úÖ GOOD: Composite keys for permission scoping and query optimization
Future<void> compositeKeyPattern(Ditto ditto) async {
  print('\n‚úÖ Pattern 3: Composite Keys (ADVANCED)\n');

  final uuid = Uuid();
  final locationId = 'LondonLiverpoolStreet';
  final orderId = uuid.v4();

  await ditto.store.execute(
    'INSERT INTO orders DOCUMENTS (:order)',
    arguments: {
      'order': {
        '_id': {
          'locationId': locationId,
          'orderId': orderId,
        },
        // Duplicate for POJO/DTO pattern (query-friendly)
        'locationId': locationId,
        'orderId': orderId,
        'status': 'pending',
        'createdAt': DateTime.now().toIso8601String(),
      }
    },
  );

  print('‚úÖ Created order with composite key');
  print('   - Good for permission scoping (locationId)');
  print('   - Query optimization (indexed fields)');
  print('   - Hierarchical data organization');
}

// ============================================================================
// Pattern 4: ULID (TIME-ORDERED)
// ============================================================================

/// ‚úÖ GOOD: ULID provides time-ordered, lexicographically sortable IDs
Future<void> ulidPattern(Ditto ditto) async {
  print('\n‚úÖ Pattern 4: ULID (TIME-ORDERED)\n');

  // Note: Requires 'ulid' package
  // import 'package:ulid/ulid.dart';
  // final ulid = Ulid().toString(); // "01ARZ3NDEKTSV4RRFFQ69G5FAV"

  // For demonstration without external package:
  final pseudoUlid = '01ARZ3NDEKTSV4RRFFQ69G5FAV';

  await ditto.store.execute(
    'INSERT INTO events DOCUMENTS (:event)',
    arguments: {
      'event': {
        '_id': pseudoUlid,
        'type': 'user_action',
        'timestamp': DateTime.now().toIso8601String(),
      }
    },
  );

  print('‚úÖ Created event with ULID');
  print('   - Lexicographically sortable (timestamp first 48 bits)');
  print('   - Good for chronological queries');
  print('   - Still collision-free with randomness component');
}

// ============================================================================
// Pattern 5: Sequential IDs (ANTI-PATTERN)
// ============================================================================

/// ‚ùå BAD: Sequential IDs cause collisions in distributed systems
Future<void> sequentialIdAntiPattern(Ditto? ditto) async {
  print('\n‚ùå Pattern 5: Sequential IDs (ANTI-PATTERN)\n');

  // ‚ùå BAD: Sequential ID generation
  final date = DateTime.now().toIso8601String().split('T')[0].replaceAll('-', '');
  final sequentialId = 'order_${date}_001';

  print('Generated sequential ID: $sequentialId');
  print('');
  print('‚ùå Problem: Collision in distributed systems');
  print('   Scenario:');
  print('   - Device A offline at 2025-01-15: generates "order_20250115_001"');
  print('   - Device B offline at 2025-01-15: generates "order_20250115_001"');
  print('   - Both devices sync ‚Üí COLLISION ‚Üí data loss or undefined behavior');
  print('');
  print('‚ùå Issues:');
  print('   - Assumes single writer (centralized system assumption)');
  print('   - Fails in offline-first, P2P mesh architecture');
  print('   - Last-write-wins may overwrite valid data');
  print('   - Collision probability increases with device count');
  print('');
  print('‚úÖ Solution: Use UUID v4, auto-generated, or ULID instead');
}

// ============================================================================
// Pattern 6: Human-Readable Display (UUID + Display Fields)
// ============================================================================

/// ‚úÖ GOOD: Combine UUID (collision-free) with human-readable display fields
Future<void> humanReadableDisplayPattern(Ditto ditto) async {
  print('\n‚úÖ Pattern 6: Human-Readable Display (UUID + Display Fields)\n');

  final uuid = Uuid();
  final orderId = uuid.v4();

  // Generate human-readable display ID with random suffix (NOT sequential!)
  final date = DateTime.now();
  final dateStr = '${date.year}${date.month.toString().padLeft(2, '0')}${date.day.toString().padLeft(2, '0')}';
  final randomSuffix = Random().nextInt(0xFFFF).toRadixString(16).toUpperCase().padLeft(4, '0');
  final displayId = 'ORD-$dateStr-$randomSuffix';  // e.g., "ORD-20251219-A7F3"

  await ditto.store.execute(
    'INSERT INTO orders DOCUMENTS (:order)',
    arguments: {
      'order': {
        '_id': orderId,                    // UUID (primary key, collision-free)
        'displayId': displayId,            // Human-readable display (date + random)
        'status': 'pending',
        'createdAt': DateTime.now().toIso8601String(),
      }
    },
  );

  print('‚úÖ Created order with human-readable display');
  print('   - _id (UUID): $orderId');
  print('   - displayId: $displayId');
  print('   - Best of both: collision-free UUID + readable display');
  print('   - Random suffix reduces user confusion (duplicate display IDs)');
}

// ============================================================================
// Pattern 7: Migration from Sequential IDs (Dual-Write Pattern)
// ============================================================================

/// ‚úÖ GOOD: Dual-write pattern for migrating from sequential to UUID IDs
Future<void> migrationDualWritePattern(Ditto ditto) async {
  print('\n‚úÖ Pattern 7: Migration from Sequential IDs (Dual-Write Pattern)\n');

  final uuid = Uuid();

  // Step 1: Generate new UUID
  final newOrderId = uuid.v4();

  // Step 2: Keep legacy ID for backward compatibility
  final legacyOrderId = 'order_20250115_001';

  // Step 3: Generate human-readable display ID
  final date = DateTime.now();
  final dateStr = '${date.year}${date.month.toString().padLeft(2, '0')}${date.day.toString().padLeft(2, '0')}';
  final randomSuffix = Random().nextInt(0xFFFF).toRadixString(16).toUpperCase().padLeft(4, '0');
  final displayId = 'ORD-$dateStr-$randomSuffix';

  // Step 4: Write with both IDs
  await ditto.store.execute(
    'INSERT INTO orders DOCUMENTS (:order)',
    arguments: {
      'order': {
        '_id': newOrderId,                // New UUID (primary)
        'legacyOrderId': legacyOrderId,   // Keep for reference
        'displayId': displayId,           // Human-readable display
        'status': 'pending',
        'createdAt': DateTime.now().toIso8601String(),
      }
    },
  );

  print('‚úÖ Migration: Dual-write pattern');
  print('   - New _id (UUID): $newOrderId');
  print('   - Display ID: $displayId');
  print('   - Legacy ID: $legacyOrderId');
  print('');

  // Step 5: Query by new UUID (primary)
  final result = await ditto.store.execute(
    'SELECT * FROM orders WHERE _id = :orderId',
    arguments: {'orderId': newOrderId},
  );
  print('‚úÖ Query by new UUID: ${result.items.length} results');

  // Step 6: Query by legacy ID (backward compatibility)
  final legacyResult = await ditto.store.execute(
    'SELECT * FROM orders WHERE legacyOrderId = :legacyId',
    arguments: {'legacyId': legacyOrderId},
  );
  print('‚úÖ Query by legacy ID: ${legacyResult.items.length} results');
  print('');
  print('Migration steps:');
  print('1. Add UUID library to project');
  print('2. Update ID generation to UUID v4');
  print('3. Keep legacy ID during transition');
  print('4. Update queries to use new UUID');
  print('5. Monitor for issues');
  print('6. Eventually remove legacy ID field');
}

// ============================================================================
// Additional Anti-Patterns
// ============================================================================

/// ‚ùå BAD: Timestamp-only IDs (no randomness)
Future<void> timestampOnlyAntiPattern(Ditto? ditto) async {
  print('\n‚ùå Anti-Pattern: Timestamp-Only IDs\n');

  // ‚ùå BAD: Timestamp-only (no randomness component)
  final timestampId = DateTime.now().millisecondsSinceEpoch.toString();

  print('Generated timestamp-only ID: $timestampId');
  print('');
  print('‚ùå Problem: Collisions within same millisecond window');
  print('   - Multiple writes within same millisecond ‚Üí collision');
  print('   - Especially problematic in high-throughput scenarios');
  print('   - No randomness component to differentiate concurrent writes');
  print('');
  print('‚úÖ Solution: Use UUID v4 or ULID (includes randomness)');
}

/// ‚ùå BAD: Counter-based IDs
Future<void> counterBasedAntiPattern(Ditto? ditto) async {
  print('\n‚ùå Anti-Pattern: Counter-Based IDs\n');

  // ‚ùå BAD: Counter-based ID generation
  var counter = 1;
  final counterId = 'product_$counter';

  print('Generated counter-based ID: $counterId');
  print('');
  print('‚ùå Problem: Requires centralized coordination');
  print('   - Multiple devices offline cannot coordinate counter');
  print('   - Device A: generates "product_1"');
  print('   - Device B: generates "product_1"');
  print('   - Collision when devices sync');
  print('');
  print('‚úÖ Solution: Use UUID v4 for independent ID generation');
}

/// ‚ùå BAD: Sequential displayId (no randomness)
Future<void> sequentialDisplayIdAntiPattern(Ditto? ditto) async {
  print('\n‚ùå Anti-Pattern: Sequential displayId (No Randomness)\n');

  // ‚ùå BAD: Sequential displayId generation
  final date = DateTime.now();
  final dateStr = '${date.year}${date.month.toString().padLeft(2, '0')}${date.day.toString().padLeft(2, '0')}';
  final sequentialDisplayId = 'ORD-$dateStr-001';

  print('Generated sequential displayId: $sequentialDisplayId');
  print('');
  print('‚ùå Problem: Poor UX when multiple devices create orders on same day');
  print('   - Device A offline at 2025-01-15: generates "ORD-20250115-001"');
  print('   - Device B offline at 2025-01-15: generates "ORD-20250115-001"');
  print('   - Both devices sync ‚Üí Duplicate display IDs confuse users');
  print('');
  print('‚ö†Ô∏è NOTE: displayId is not the document ID (_id ensures uniqueness)');
  print('         Duplicate displayIds cause UX issues, not system errors');
  print('');
  print('‚úÖ Solution: Use random suffix to reduce user confusion');
  print('   Example: ORD-20251219-A7F3 (date + 4-digit random hex)');
}

// ============================================================================
// Decision Tree Helper
// ============================================================================

/// Decision tree to choose the right ID generation pattern
void printDecisionTree() {
  print('\nüìã Decision Tree: Choosing ID Generation Pattern\n');
  print('Need to generate document _id?');
  print('  ‚Üì');
  print('Human-readable required for debugging?');
  print('  ‚Üì YES ‚Üí Add display field alongside UUID');
  print('  |         (_id: UUID, displayId: "ORD-2025-042")');
  print('  ‚Üì NO');
  print('  ‚Üì');
  print('Chronological sorting required?');
  print('  ‚Üì YES ‚Üí Use ULID (time-ordered)');
  print('  ‚Üì NO');
  print('  ‚Üì');
  print('Permission scoping needed?');
  print('  ‚Üì YES ‚Üí Use Composite Keys');
  print('  ‚Üì NO');
  print('  ‚Üì');
  print('Want simplest approach?');
  print('  ‚Üì YES ‚Üí Omit _id (auto-generated)');
  print('  ‚Üì NO');
  print('  ‚Üì');
  print('‚Üí Use UUID v4 (general-purpose, recommended)');
}

// ============================================================================
// Platform Comparison
// ============================================================================

/// Platform-specific UUID generation examples
void printPlatformComparison() {
  print('\nüîß Platform-Specific UUID Generation\n');

  print('Dart/Flutter:');
  print('```dart');
  print('import \'package:uuid/uuid.dart\';');
  print('final uuid = Uuid();');
  print('final id = uuid.v4();');
  print('```\n');

  print('JavaScript/TypeScript:');
  print('```javascript');
  print('import { v4 as uuidv4 } from \'uuid\';');
  print('const id = uuidv4();');
  print('```\n');

  print('Swift:');
  print('```swift');
  print('import Foundation');
  print('let id = UUID().uuidString.lowercased()');
  print('```\n');

  print('Kotlin:');
  print('```kotlin');
  print('import java.util.UUID');
  print('val id = UUID.randomUUID().toString()');
  print('```');
}

// ============================================================================
// Main Demo
// ============================================================================

/// Main demo function to run all ID generation patterns
Future<void> main() async {
  print('=' * 80);
  print('ID Generation Patterns for Distributed Systems');
  print('=' * 80);
  print('');

  // Initialize Ditto (placeholder - replace with actual initialization)
  // final ditto = await initDitto();

  printDecisionTree();

  print('\n' + '=' * 80);
  print('Pattern Demonstrations');
  print('=' * 80);

  // Pattern 1: UUID v4 (RECOMMENDED)
  // await uuidV4Pattern(ditto);

  // Pattern 2: Auto-Generated (SIMPLEST)
  // await autoGeneratedPattern(ditto);

  // Pattern 3: Composite Keys (ADVANCED)
  // await compositeKeyPattern(ditto);

  // Pattern 4: ULID (TIME-ORDERED)
  // await ulidPattern(ditto);

  // Pattern 5: Sequential IDs (ANTI-PATTERN)
  await sequentialIdAntiPattern(null);

  // Pattern 6: Human-Readable Display
  // await humanReadableDisplayPattern(ditto);

  // Pattern 7: Migration Pattern
  // await migrationDualWritePattern(ditto);

  // Additional Anti-Patterns
  await timestampOnlyAntiPattern(null);
  await counterBasedAntiPattern(null);
  await sequentialDisplayIdAntiPattern(null);

  printPlatformComparison();

  print('\n' + '=' * 80);
  print('Summary:');
  print('=' * 80);
  print('‚úÖ UUID v4: General-purpose, recommended (collision-free)');
  print('‚úÖ Auto-Generated: Simplest (omit _id, Ditto auto-generates)');
  print('‚úÖ Composite Keys: Permission scoping, query optimization');
  print('‚úÖ ULID: Time-ordered sorting, chronological queries');
  print('‚ùå Sequential IDs: AVOID (collision risk in distributed systems)');
  print('‚ùå Timestamp-Only: AVOID (collisions within same millisecond)');
  print('‚ùå Counter-Based: AVOID (requires centralized coordination)');
  print('‚ùå Sequential displayId: AVOID (poor UX - consider random suffix)');
  print('=' * 80);
  print('');
  print('Key Takeaway:');
  print('In distributed, offline-first systems, collision-free ID generation');
  print('is critical. UUID v4 provides the best balance of simplicity,');
  print('safety, and platform support.');
  print('=' * 80);
}
